model InvoiceItem {
  id            String    @id @default(uuid())
  invoiceId     String
  invoice       Invoice   @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  description   String
  quantity      Decimal   @db.Decimal(10, 2)
  unitPrice     Decimal   @db.Decimal(10, 2)
  taxRateId     String
  taxRate       TaxRate   @relation(fields: [taxRateId], references: [id])
  netAmount     Decimal   @db.Decimal(10, 2)
  grossAmount   Decimal   @db.Decimal(10, 2)
  taxAmount     Decimal   @db.Decimal(10, 2)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
}

model TaxRate {
  id             String    @id @default(uuid())
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id])
  name           String
  rate           Decimal   @db.Decimal(5, 4) // e.g., 0.19 for 19%
  isDefault      Boolean   @default(false)
  invoiceItems   InvoiceItem[]
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  @@unique([organizationId, name])
}

model Payment {
  id            String    @id @default(uuid())
  invoiceId     String
  invoice       Invoice   @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  amount        Decimal   @db.Decimal(10, 2)
  paymentDate   DateTime
  method        String
  transactionId String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
}

model UploadJob {
  id             String       @id @default(uuid())
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id])
  userId         String
  user           User         @relation(fields: [userId], references: [id])
  fileName       String
  fileUrl        String
  status         UploadStatus @default(PENDING)
  totalRows      Int?
  processedRows  Int?
  failedRows     Int?
  errorMessage   String?
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
}

model AuditLog {
  id             String    @id @default(uuid())
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id])
  userId         String?
  user           User?     @relation(fields: [userId], references: [id])
  action         String
  entityType     String
  entityId       String?
  details        Json?
  ipAddress      String?
  createdAt      DateTime  @default(now())

  invoices       Invoice[] // For linking finalized invoices to their audit log entry
}

model ShopifyConnection {
  id             String       @id @default(uuid())
  organizationId String       @unique // One-to-one per organization
  organization   Organization @relation(fields: [organizationId], references: [id])
  shopName       String
  accessToken    String // Encrypted
  scopes         String
  isActive       Boolean      @default(true)
  lastSyncAt     DateTime?
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}
```

**ملاحظات حول مخطط Prisma:**

*   **الأنواع المخصصة (Enums):** تم تعريف أنواع `UserRole`, `OrderStatus`, `InvoiceStatus`, و `UploadStatus` لتوفير قيم محددة ومتحكم بها للحقول ذات الصلة.
*   **`@default(uuid())`:** يستخدم لتوليد معرفات فريدة تلقائيًا عند إنشاء سجل جديد.
*   **`@default(now())` و `@updatedAt`:** يتم استخدامها لإدارة الطوابع الزمنية تلقائيًا.
*   **`@unique`:** يضمن تفرد القيم في الحقل المحدد.
*   **`@relation`:** يحدد العلاقات بين الجداول. `onDelete: Cascade` يعني أنه عند حذف مستخدم، سيتم حذف جميع الجلسات والحسابات المرتبطة به تلقائيًا.
*   **`@db.Decimal(10, 2)` و `@db.Decimal(5, 4)`:** يحدد دقة ونطاق الأرقام العشرية، وهو أمر بالغ الأهمية للبيانات المالية.
*   **`Json?`:** يسمح بتخزين بيانات JSON مرنة في حقل `details` في `AuditLog`.
*   **`@@unique([field1, field2])`:** يستخدم لفرض التفرد على مجموعة من الحقول، مثل `[organizationId, shopifyCustomerId]` لضمان أن معرف عميل Shopify فريد داخل كل منظمة.
*   **الرموز المميزة (Tokens):** `refreshToken` و `accessToken` في `Account`، و `accessToken` في `ShopifyConnection` يجب أن تكون مشفرة عند التخزين في قاعدة البيانات لتعزيز الأمان.

## مخططات التحقق من الصحة (Validation Schemas)

سنستخدم مكتبة [Zod](https://zod.dev/) لتعريف مخططات التحقق من الصحة في TypeScript. توفر Zod طريقة قوية وآمنة للأنواع للتحقق من صحة البيانات الواردة، مما يضمن أن البيانات تتوافق مع القواعد المحددة قبل معالجتها أو تخزينها. سنقوم بتعريف مخططات للتحقق من صحة صفوف CSV المستوردة وحمولات API.

### 1. التحقق من صحة صفوف CSV (طلبات Shopify)

عند استيراد ملفات CSV من Shopify، نحتاج إلى التحقق من صحة كل صف لضمان أن البيانات كاملة وصحيحة قبل محاولة معالجتها وتحويلها إلى كيانات داخلية (مثل `Order` و `Customer`). سنفترض أن ملف CSV يحتوي على حقول نموذجية لطلبات Shopify. يجب أن يتم تعيين هذه الحقول إلى مخططنا الداخلي.

```typescript
// src/schemas/shopify-order-csv.schema.ts
import { z } from 'zod';

export const shopifyOrderCsvRowSchema = z.object({
  'Order Name': z.string().min(1, { message: 'Order Name darf nicht leer sein.' }),
  'Email': z.string().email({ message: 'Ungültiges E-Mail-Format.' }).optional().or(z.literal('')), // Optional, but if present, must be valid email
  'Financial Status': z.string().min(1, { message: 'Financial Status darf nicht leer sein.' }),
  'Fulfillment Status': z.string().min(1, { message: 'Fulfillment Status darf nicht leer sein.' }),
  'Subtotal': z.string().regex(/^\d+(\.\d{1,2})?$/, { message: 'Ungültiges Subtotal-Format.' }).transform(Number), // Convert to number
  'Shipping': z.string().regex(/^\d+(\.\d{1,2})?$/, { message: 'Ungültiges Shipping-Format.' }).transform(Number),
  'Taxes': z.string().regex(/^\d+(\.\d{1,2})?$/, { message: 'Ungültiges Taxes-Format.' }).transform(Number),
  'Total': z.string().regex(/^\d+(\.\d{1,2})?$/, { message: 'Ungültiges Total-Format.' }).transform(Number),
  'Currency': z.string().length(3, { message: 'Währung muss 3 Zeichen lang sein.' }).default('EUR'),
  'Lineitem quantity': z.string().regex(/^\d+$/, { message: 'Ungültiges Mengenformat.' }).transform(Number),
  'Lineitem name': z.string().min(1, { message: 'Lineitem Name darf nicht leer sein.' }),
  'Lineitem price': z.string().regex(/^\d+(\.\d{1,2})?$/, { message: 'Ungültiges Lineitem Price-Format.' }).transform(Number),
  'Billing Name': z.string().min(1, { message: 'Billing Name darf nicht leer sein.' }),
  'Billing Address1': z.string().min(1, { message: 'Billing Address1 darf nicht leer sein.' }),
  'Billing Zip': z.string().min(1, { message: 'Billing Zip darf nicht leer sein.' }),
  'Billing City': z.string().min(1, { message: 'Billing City darf nicht leer sein.' }),
  'Billing Country': z.string().min(1, { message: 'Billing Country darf nicht leer sein.' }).default('Germany'),
  'Shipping Name': z.string().min(1, { message: 'Shipping Name darf nicht leer sein.' }),
  'Shipping Address1': z.string().min(1, { message: 'Shipping Address1 darf nicht leer sein.' }),
  'Shipping Zip': z.string().min(1, { message: 'Shipping Zip darf nicht leer sein.' }),
  'Shipping City': z.string().min(1, { message: 'Shipping City darf nicht leer sein.' }),
  'Shipping Country': z.string().min(1, { message: 'Shipping Country darf nicht leer sein.' }).default('Germany'),
  'Shopify ID': z.string().min(1, { message: 'Shopify ID darf nicht leer sein.' }),
  // Add other relevant Shopify CSV fields as needed
});

export type ShopifyOrderCsvRow = z.infer<typeof shopifyOrderCsvRowSchema>;
```

**ملاحظات حول مخطط `shopifyOrderCsvRowSchema`:**

*   **`z.string().min(1)`:** يضمن أن الحقل موجود وغير فارغ.
*   **`z.string().email().optional().or(z.literal(''))`:** يسمح بحقل البريد الإلكتروني أن يكون اختياريًا أو سلسلة فارغة، ولكن إذا كان موجودًا، فيجب أن يكون بتنسيق بريد إلكتروني صالح.
*   **`z.string().regex(...).transform(Number)`:** يستخدم للتأكد من أن الحقل يطابق نمطًا رقميًا (مع دعم الأرقام العشرية) ثم يحوله إلى نوع `Number`.
*   **`default()`:** يوفر قيمة افتراضية إذا كان الحقل مفقودًا.
*   **رسائل الخطأ باللغة الألمانية:** تم توفير رسائل خطأ واضحة ومحددة باللغة الألمانية لتوجيه المستخدمين بشكل أفضل.

### 2. التحقق من صحة حمولات API (API Payloads)

سنقوم بتعريف مخططات Zod لحمولات API لضمان أن البيانات المرسلة إلى الواجهة الخلفية صالحة. على سبيل المثال، مخطط لإنشاء فاتورة جديدة.

```typescript
// src/schemas/invoice.schema.ts
import { z } from 'zod';

export const createInvoiceSchema = z.object({
  organizationId: z.string().uuid({ message: 'Ungültige Organisations-ID.' }),
  customerId: z.string().uuid({ message: 'Ungültige Kunden-ID.' }),
  orderId: z.string().uuid({ message: 'Ungültige Bestell-ID.' }).optional(),
  templateId: z.string().uuid({ message: 'Ungültige Vorlagen-ID.' }),
  issueDate: z.string().datetime({ message: 'Ungültiges Ausstellungsdatum-Format.' }),
  serviceDate: z.string().datetime({ message: 'Ungültiges Leistungsdatum-Format.' }).optional(),
  dueDate: z.string().datetime({ message: 'Ungültiges Fälligkeitsdatum-Format.' }),
  currency: z.string().length(3, { message: 'Währung muss 3 Zeichen lang sein.' }).default('EUR'),
  items: z.array(z.object({
    description: z.string().min(1, { message: 'Beschreibung darf nicht leer sein.' }),
    quantity: z.number().positive({ message: 'Menge muss positiv sein.' }),
    unitPrice: z.number().positive({ message: 'Einzelpreis muss positiv sein.' }),
    taxRateId: z.string().uuid({ message: 'Ungültige Steuersatz-ID.' }),
  })).min(1, { message: 'Mindestens ein Rechnungsposten erforderlich.' }),
});

export type CreateInvoicePayload = z.infer<typeof createInvoiceSchema>;

export const updateInvoiceSchema = createInvoiceSchema.partial().extend({
  id: z.string().uuid({ message: 'Ungültige Rechnungs-ID.' }),
  status: z.enum(['DRAFT', 'SENT', 'PAID', 'OVERDUE', 'CANCELLED'], { message: 'Ungültiger Rechnungsstatus.' }).optional(),
});

export type UpdateInvoicePayload = z.infer<typeof updateInvoiceSchema>;
```

**ملاحظات حول مخططات API:**

*   **`z.string().uuid()`:** يتحقق من أن السلسلة هي معرف UUID صالح.
*   **`z.string().datetime()`:** يتحقق من أن السلسلة هي تنسيق تاريخ ووقت صالح.
*   **`z.array(...).min(1)`:** يضمن أن المصفوفة تحتوي على عنصر واحد على الأقل.
*   **`z.number().positive()`:** يضمن أن الرقم موجب.
*   **`createInvoiceSchema.partial().extend(...)`:** يوضح كيفية إنشاء مخطط تحديث عن طريق جعل جميع الحقول اختيارية ثم إضافة حقول جديدة أو تعديل حقول موجودة.
*   **`z.enum(...)`:** يحد من القيم المسموح بها لحقل `status` إلى مجموعة محددة مسبقًا.

### 3. قيود الفواتير الألمانية

لضمان الامتثال للمتطلبات القانونية الألمانية للفواتير، يجب تطبيق القيود التالية على مستوى التطبيق وقاعدة البيانات:

*   **`fortlaufende Rechnungsnummer` (رقم الفاتورة المتسلسل):** يجب أن يكون لكل فاتورة رقم فريد ومتسلسل ضمن المنظمة. سيتم فرض ذلك من خلال حقل `invoiceNumber` الفريد في جدول `Invoice` بالاشتراك مع `organizationId`.
*   **`Ausstellungsdatum` (تاريخ الإصدار):** حقل `issueDate` إلزامي في جدول `Invoice`.
*   **`Leistungsdatum` (تاريخ أداء الخدمة/التسليم):** حقل `serviceDate` اختياري ولكنه موصى به في جدول `Invoice`.
*   **`USt-IdNr.` (رقم تعريف ضريبة القيمة المضافة):** حقل `taxId` في `Organization` و `Customer` اختياري ولكنه مطلوب في سياقات معينة (مثل الفواتير بين الشركات داخل الاتحاد الأوروبي).
*   **`Steuersätze (z. B. 19%/7%)` (معدلات الضرائب):** سيتم تخزينها في جدول `TaxRate` وتطبيقها على `InvoiceItem`.
*   **`Netto/Brutto` (صافي/إجمالي):** يجب حساب وعرض المبالغ الصافية والإجمالية ومبالغ الضرائب بشكل واضح لكل عنصر فاتورة وإجمالي الفاتورة.
*   **`IBAN/BIC`:** حقول `iban` و `bic` في `Organization` اختياريان ولكن موصى بهما لتضمين معلومات الدفع في الفواتير.
*   **`Adresse/PLZ/Ort` (العنوان/الرمز البريدي/المدينة):** حقول العنوان الكاملة مطلوبة لكل من المنظمة والعميل.
*   **`vollständige Anbieter-/Kundenangaben` (تفاصيل المورد/العميل الكاملة):** يجب أن تتضمن الفواتير معلومات كاملة عن كل من مصدر الفاتورة (المنظمة) والعميل.

## الخلاصة

من خلال هذا التصميم الدقيق لمخطط قاعدة البيانات ومخططات التحقق من الصحة، نضمن أن التطبيق سيتعامل مع البيانات المالية بطريقة آمنة، متسقة، ومتوافقة مع المتطلبات القانونية الألمانية. يوفر استخدام Prisma و Zod أساسًا قويًا لتطوير تطبيق مستقر وقابل للصيانة.

